\thispagestyle{headings}
\chapter*{Introduzione} \label{cap:introduzione}

\noindent Il lavoro svolto si concentra sulla soluzione numerica efficiente di \textit{\textbf{PDE (Partial Differential Equation)}} che modellano un particolare problema di vegetazione, per mezzo di metodi numerici paralleli che utilizzano \textit{\textbf{GPU (Graphics Processing Unit)}}. 

\noindent Più precisamente, verrà preso in considerazione un sistema di PDE che rappresenta un modello di vegetazione in zone climatiche semi-aride, e costituisce un esempio del principio di autorganizzazione in ecologia. Tale sistema è stato introdotto per studiare come due specie erbacee competono per la stessa risorsa limitata (l'acqua) riuscendo a sopravvivere. \cite{bib:self-organization}

\noindent Per risolvere numericamente questo tipo di PDE, che è funzione spazio-tempo, è necessario discretizzare spazialemnte il problema generando così un sistema di \textit{\textbf{ODE (Ordinary Differential Equation)}}, che deve essere poi discretizzato rispetto al tempo. Una risoluzione efficiente prevede che il metodo impiegato non sia troppo costoso, cioè che coinvolga il minor numero possibile di valutazioni di funzioni e inversioni di matrici. Dunque, bisogna scegliere un metodo che sia numericamente stabile e non sia pesante computazionalmente. 

\noindent Un buon compromesso nella scelta del metodo di discretizzazione rispetto al tempo è rappresentato da una classe di metodi espliciti chiamati \textit{\textbf{peer methods}}. I peer methods sono metodi numerici basati su più passi (stage) che fanno parte della classe dei \textit{\textbf{General Linear Methods (GLM)}} \cite{general-linear-methods} 
%Sono più recenti dei metodi di Runge-Kutta
e hanno delle proprietà per cui il loro uso può risultare molto conveniente. Infatti, in questi metodi, tutte le fasi sono calcolate con la stessa accuratezza della soluzione che avanza, e questo assicura che i peer methods non soffrano di riduzione dell'ordine di accuratezza della soluzione finale.
%a differenza di quanto accade per i metodi Runge-Kutta \cite{runge-kutta-convergence}. 

\noindent L'attività svolta si è concentrata in primo luogo sulla scrittura di un algoritmo basato sul modello numerico che dati in input i parametri del modello restituisca in output la soluzione numerica del sistema \eqref{eq:main-equation}. Tale algoritmo è stato poi implementato in linguaggio di programmazione C, in un ambiente di calcolo sequenziale, organizzando l'algoritmo in più macromoduli.
\noindent Successivamente, si sono osservate le prestazioni del software e individuate le parti più critiche per cui fosse utile e necessario pensare ad una strategia di parallelizzazione. È stato quindi formulato un algoritmo parallelo, con relativa strategia di parallelizzazione, la quale mira proprio ad eseguire in parallelo i due stage (passi) dell'equazione relativa al calcolo dei peer methods. L'algoritmo parallelo è stato poi è stato implementato in ambiente ad alte prestazioni, sfruttando le architetture \textit{\textbf{GPU (Graphics Processing Units)}} e impiegando l'ambiente \textit{\textbf{CUDA}} \cite{cuda-environment}. 
Ricordiamo che oggigiorno la scelta delle GPU diventa quasi obbligatoria grazie alla possibilità che offrono di risolvere problemi di grandi dimensioni, mediante opportuni algoritmi paralleli, in un tempo di esecuzione ridotto.
Sono state usate le API in linguaggio C che CUDA mette a disposizione per la creazione del software parallelo. La scelta del linguaggio C è da ascriversi non solo al fatto che è stato ampiamente trattato durante il corso di studi ma anche al fatto che offre un controllo a basso livello della memoria, permettendo di utilizzare in maniera efficiente le risorse delle GPU. Infine, sono state analizzate e confrontate le performance osservando come il software parallelo abbia prestazioni nettamente migliori rispetto al sequenziale.

\noindent Il resto della tesi è organizzata come segue. Nel capitolo \ref{cap:modello-numerico} verrà presentato il problema di vegetazione, il modello matematico e i metodi di discretizzazione impiegati per passare al modello numerico. Verranno presentati in maniera più approfondita i peer methods e infine l'algoritmo sequenziale che risolve il problema di vegetazione. Il capitolo si conclude con i test effettuati sull'implementazione sequenziale dell'algoritmo. Nel capitolo \ref{cap:GPU} si parlerà delle GPU e dell'ambiente CUDA, con qualche esempio di codice in linguaggio C e una breve presentazione delle funzioni di libreria più usate. Nel capitolo \ref{cap:approccio-parallelo} si discuterà della strategia di parallelizzazione scelta e dell'algoritmo parallelo. Nel capitolo \ref{cap:test} verranno effettuati i test del codice parallelo e confrontati con i risultati ottenuti dalla controparte sequenziale, confermando l'efficienza dell'approccio parallelo.

\newpage